## 1.1 역사의 흐름은 무엇인가?

자바 8은 간결한 코드, 멀티코어 프로세서(병렬 실행)의 쉬운 활용이라는 두 가지 요구사항을 기반으로 개발되었다. 업데이트 내용을 요약하자면 다음과 같다.

- 스트림 API
- 메서드에 코드를 전달하는 기법
- 인터페이스의 default 메서드

### 병렬 실행의 역사

요즘 PC에는 듀얼 혹은 쿼드코어 이상의 CPU가 탑재되어 있다. 자바 8 등장 이전에는 멀티코어를 사용하지 않고 그 중에 하나의 코어만 사용했다. 나머지 코어는 유휴 idle 상태로 두거나, 운영체제나 바이러스 검사 프로그램과 프로세스 파워를 나눠서 사용했다.
나머지 코어를 활용하기 위해 스레드를 사용하는 것은 대부분의 자바 개발자의 숙명?이었다. 그러나 이는 쉽지 않다. 자바 버전 별로 병렬 실행 환경 관리 방법을 알아보자

- 자바 1.0에서는 스레드와 락, 메모리 모델을 지원했다.
- 자바 5에서는 스레드 풀, 병렬 실행을 지원하는 컬렉션이 등장하였다.
- 자바 7에서는 fork/join 프레임워크를 제공하였다.

이들의 사용 방법은 특별한 전문가가 아닌 이상 매우 어려웠다. 자바 8에서는 병렬 실행을 새롭고 단순한 방식으로 접근할 수 있는 방법을 제공한다. 또한 자바 9에서는 Reactive Programming이라는 고성능 병렬 실행 기법을 지원한다.

### 병렬 실행을 쉽게 하기 위한 간결한 코드

자바 8은 데이터베이스 query문을 처리하는 것 처럼 병렬 연산을 지원하는 스트림 API를 제공한다. 원하는 작업을 자바로 작성하면(고수준 언어로 표현하면) 스트림 API가 최적의 저수준 실행 방법을 선택하는 방식이다. 즉, 스트림을 이용하면 멀티코어 CPU를 이용하는 synchronized를 사용하지 않아도 된다.
스트림 API가 등장함에 따라 메서드에 **코드를 전달하는 간결한 기법**(메서드 참조와 람다)과 인터페이스의 **default 메소드** 또한 등장하였다. 이 들은 **함수형 프로그래밍**에서 엄청난 시너지를 발휘한다.

정리하자면 자바 8은 자바의 멀티코어 병렬 실행을 스트림 API를 이용하여 더 쉽게 이용할 수 있도록 진화하기 위해서 진화하였다는 점을 알 수 있다.

## 1.2 왜 아직도 자바는 변화하는가?

자바는 출발이 좋았다. 처음부터 다양하고 유용한 라이브러를 포함하는 객체지향 언어로 시작하였다. 스레드와 락을 이용한 소소한 동시성도 지원하였다. 코드를 JVM 바이트 코드로 컴파일하는 자바의 특성상 인터넷 애플릿 프로그램의 주요 언어가 되었다. (현재는 웹 표준의 등장으로 거의 사용하지 않음) 또한 자바는 스마트카드, 토스터, 셋톱박스, 자동차 브레이크 시스템 등 다양한 임베디드 컴퓨팅 분야에서도 성공적으로 활약하고 있다.

최근들어 프로그래밍 언어 생태계의 변화의 바람이 불었다. 프로그래머는 테라바이트 이상의 빅데이터를 다뤄야 하는 문제에 직면하면서 멀티코어 컴퓨터나 클러스터 컴퓨팅을 이용해서 빅데이터를 효과적으로 처리할 필요성이 대두되었다. 즉, 병렬 처리를 활용해야 하는데 자바 8 이전은 이 것이 매우 어려웠다. 프로그래밍의 생태계에 따라 자바가 살아남기 위해 진화한 것이다.

### 스트림 처리

**스트림**이란 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임이다.
유닉스 명령어 `|` 파이프를 이용해 연결하는 것도 스트림 처리이다.

`cat file1 file2 | tr "[A-Z]" "[a-z]" | sort | tail -3`

자바8에서 제공하는 스트림 API 가 이런 파이프라인을 만드는데 필요한 다양한 메소드를 제공한다고 생각하면 된다.
스트림 API의 핵심은 기존엔 한번에 한항목을 처리하던 것을 고수준으로 추상화하여 일련의 스트림으로 만들어 처리가 가능하다는 것.
또한 여러 CPU 코어를 쉽게 할당할 수 있고 병렬성을 얻을 수 있다.

### 동작 파라미터화로 메서드에 코드 전달하기

코드 일부를 API로 전달하는 기능이다. 위 리눅스 명렁어 예시에서 예를 들어 sort 에 어떤 기준을 넣어 sorting 하고 싶을 수도 있다.
자바8 이전에는 이를 수행하려면 Comparator 객체를 만들어 sort 에 넘겨주어야하지만 이는 너무 복잡하다. 자바8 에서는 동작 파라미터화를 이용하여 이를 편리하게 해준다.

### 병렬성과 공유 가변 데이터

스트림 API 를 통해서 병렬성을 쉽게 얻을 수 있다.
다른 코드와 동시에 실행하더라도 안전하게 실행할 수 있는 코드를 만드려면 공유된 가변 데이터에 접근하지 않아야 한다. 이는 함수형 프로그래밍 패러다임의 핵심적인 사항이다.

## 1.3 자바 함수

프로그래밍 언어에서 **함수(Function)**라는 용어는 정적 메서드를 의미한다. 메서드는 클래스 내부에 종속되어 있는 동작의 체계를 의미한다. 자바희 함수는 이에 더해 **수학적인 함수**처럼 사용되며 부작용을 일으키지 않는 함수를 의미한다.

함수가 필요한 이유를 알아보기 전에 일급 값 또는 일급 시민이라고 불리는 용어의 의미를 알아보자.
전통적으로 미국 시민 권리에서 유래한 해당 용어는 바꿀 수 있는 값을 일급 시민이라고 불러왔다. 예를 들어 int나 double 형식의 기본값 및 String 형식의 객체가 일급 시민에 해당한다. 하지만 클래스나 메서드와 같은 경우 값의 구조를 표현하는 데 도움이 될 수는 있지만, 그 자체로 값이 될 수는 없기 때문에 이급 시민에 해당한다.

이렇게 이급 시민인 메서드를 런타임에 전달할 수 있는 일급 시민으로 만든다면 프로그래밍에 유용하게 활용될 수 있다.

### 메서드와 람다를 일급 시민으로

스칼라와 그루비 같은 언어에서 메서드를 일급값으로 사용하며 프로그래머가 활용할 수 있는 도구가 다양해지면서 프로그래밍이 수월해진다는 사실을 확인하였다. 이에 자바 8 또한 메서드를 값으로 취급할 수 있게 하기 위하여 새로운 기능을 제공한다.

#### 메서드 참조

자바 8 이전에는 new 연산자를 이용하여 객체를 생성하고 객체 참조를 이용하여 객체를 이리저리 주고받았다. 하지만 자바 8에서는 메서드 참조를 이용할 수 있다.

다음은 디렉토리에서 모든 파일을 찾는 코드이다.

```Java
//자바 8 이전
File[] hiddenFiles = new File(".").listFiles(new FileFilter() {
    public boolean accept(File file) {
        return file.isHidden();
    }
})
```

```Java
//자바 8 : 메서드 참조 적용
File[] hiddenFiles = new File(".").listFiles(File::isHidden);
```

메서드 참조를 이용하면 한줄로 코드 작성이 가능하고 가독성 면에서도 훨씬 더 좋다.  
File 클래스에서는 isHidden() 메서드가 존재하는데 굳이 FileFilter()로 isHidden을 감쌀 필요가 없이 자바 8의 `::`를 이용해서 listFiles에 직접 전달할 수 있다.

#### 람다 : 익명 함수

자바 8에서는 기명 메서드 뿐만 아니라 **람다**(또는 익명 함수)도 일급값으로 취급한다.  
예를 들어 `(int x) -> x + 1`, 즉 'x라는 인수를 호출하면 x + 1을 반환'하는 동작을 수행하도록 코드를 구현할 수 있다.  
직접 메서드를 정의할 수 있지만, 이용할 수 있는 편리한 클래스나 메서드가 없을 때 람다 문법을 이용하면 더 간결하게 코드를 작성할 수 있다.

### 코드 넘겨주기 : 예제

Apple 클래스와 getColor 메서드가 있고, Apples 리스트를 포함하는 변수 inventory가 있다고 가정할 때, 원하는 조건에 맞게 리스트를 반환하는 프로그램을 구현해 보자. 이때 누군가 150그램 이상인 사과만 필터링하고 싶다면 다음과 같이 코드를 작성할 수 있을 것이다.

```Java
public static List<Apple> filterHeavyApples(List<Apple> inventory) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
        if (apple.getWeight() > 150) {
            result.add(apple);
        }
    }
    return result;
}
```

만약 무게를 기준으로 하는 것이 아닌 색깔을 기준으로 한다면, if문 내부의 코드만 달라지고 완전히 똑같은 구조의 코드가 된다. 이는 복사&붙여넣기 식의 코드 작성이며 버그가 발생할 경우 모든 코드를 고쳐야 하는 문제점이 발생한다.

하지만 자바 8에서는 코드를 인수로 넘겨줄 수 있으므로 필터 메서드를 중복으로 구현할 필요가 없어 아래와 같이 구현할 수가 있다.

```Java
public static boolean isHeavyApple(Apple apple) {
    return apple.getWeight() > 150;
}

static List<Apple> filterApples(List<Apple> inventory, Predicate<Apple> p) { //조건 판별 함수가 Predicate 파라미터로 전달
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
        if (p.test(apple)) { //조건 부합 여부 확인
            result.add(apple);
        }
    }
    return result;
}
```

위에서 쓰인 Predicate는 인수로 값을 받아 참 또는 거짓을 반환하는 함수를 의미하는 용어이다. 이제 여러 가지 조건을 검증하기 위해서 똑같은 코드를 복사&붙여넣기 하는 식으로 작성할 필요 없이 검증 메서드만 추가적으로 작성하면 된다. `filterApples()`메서드는 다음과 같이 호출하여 조건을 판별할 수 있다.

```Java
filterApples(inventory, Apple::isHeavyApple);
```

### 메서드 전달에서 람다로

메서드를 값으로 전달하는 것은 유용한 기능이지만 `isHeavyApple`처럼 한두 번만 사용할 메서드를 매번 정의하는 것은 비효율적이다. 자바 8에서는 람다(익명 함수)를 이용하여 이 문제를 해결할 수 있다.

```Java
filterApples(inventory, (Apple a) -> a.getWeight() > 150);
```

하지만 람다가 몇 줄 이상으로 길어진다면 이름을 가진 기명 메서드로 정의하고 메서드 참조를 활용하는 것이 더 바람직하다. 코드의 명확성이 우선시되어야 한다.

## 1.4 스트림

대부분 자바 애플리케이션은 컬렉션을 만들고 활용한다. 하지만 이는 항상 간단하지 않다. 다음은 리스트에서 고가의 트랜잭션만 필터링한 리스트를 만드는 코드이다.

```Java
 // 그룹화된 트랜잭션을 더할 Map 생성
Map<Currency, List<Transaction>> transactionsByCurrencies = new HashMap<>();
// 트랜잭션의 리스트를 반복
for (Transaction transcation : transactions) {
    // 고가의 트랜잭션을 필터링
    if (transaction.getPrice() > 1000) {
    // 트랜잭션의 통화 추출
    Currency currency = transaction.getCurrency();
    List<Transaction> transactionsForCurrency = transactionsByCurrencies.get(currency);
    // 현재 통화의 그룹화된 맵에 항목이 없으면 새로 만든다.
    if (transactionsForCurrency == null) {
        transactionsForCurrency = new ArrayList<>();
        transactionsByCurrencies.put(currency, transactionsForCurrency);
    }
    // 현재 탐색된 트랜잭션을 같은 통화의 트랜잭션 리스트에 추가한다.
    transactionsForCurrency.add(transaction);
    }
}
```

이 코드에는 중첩된 제어 흐름 문장이 많아 코드를 한 번에 이해하기도 어렵다.

스트림 API를 이용하면 간단하게 작성할 수 있다.

```Java

import static java.util.stream.Collectors.groupingBy;
Map<Currency, List<Transaction>> transactionsByCurrencies =
    transactions.stream()
        .filter((Transaction t) -> t.getPrice() > 1000) // 고가의 트랜잭션 필터링
        .collection(groupingBy(Transaction::getCurrency)); //통화로 그룹화함
```

스트림 API를 이용하면 컬렉션 API와는 다른 방식으로 데이터를 처리할 수 있다는 사실을 알 수 있다.

컬렉션에서는 for-each문을 이용하여 반복 과정을 직접 처리해야 했다. 이런 방식을 **외부 반복**이라고 한다. 반면 스트림에서는 라이브러리 내부에서 모든 데이터가 처리된다. 이를 **내부 반복**이라고 한다.

거대한 데이터를 컬렉션을 이용하여 처리하려면 단일 CPU로는 매우 오랜 시간이 걸릴 수 있다. 하지만 대부분의 컴퓨터는 멀티코어 컴퓨터이고 서로 다른 CPU 코어에 작업을 각각 할당해서 처리 시간을 줄일 수 있다. 자바에서는 **멀티스레딩** 코드를 구현해서 병렬성을 이용할 수 있지만 쉽지 않다.

### 멀티스레딩은 어렵다

멀티스레딩 환경에서 각각의 스레드는 동시에 공유된 데이터에 접근하고 갱신할 수 있다. 스레드를 잘 제어하지 못한다면 데이터가 예상치 못한 방식으로 변한다. 전통적으로 자바에서 멀티스레딩 환경에서는 synchronized를 자주 활용하였지만 많은 버그가 발생할 수 있다. 자바 8에서는 synchronized가 필요하지 않는 함수형 프로그래밍 형식의 스트림 기반 병렬성을 이용하도록 권고한다.
![두 스레드가 공유된 sum 변수에 접근하는 그림](image.png)
자바 8은 스트림 API로 '컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제', 그리고 '멀티코어 활용의 어려움'이라는 두 가지 문제를 모두 해결하였다. 기존의 컬렉션에서는 데이터를 처리할 때 반복되는 패턴이 너무 많았다. 여기서 말하는 반복되는 패턴은 **조건에 따른 데이터 필터링**, **데이터 추출**, **데이터 그룹화** 등을 의미한다. 이러한 동작들을 쉽게 병렬화할 수 있다.

컬렉션을 필터링할 수 있는 가장 빠르고 효율적인 방법은

1. 컬렉션을 스트림으로 바꾸고
2. 병렬로 처리한 다음
3. 컬렉션으로 다시 복원하는 것이다.

무거운 사과를 순차 처리 또는 병렬 처리로 필터링하는 코드는 다음과 같다.

#### 순차 처리 방식

```Java
import static java.util.stream.Collectors.toList;
List<Apple> heavyApples =
	inventory.stream().filter((Apple a) -> a.getWeight() > 150)
	                  .collect(toList());
```

#### 병렬 처리 방식

```Java
import static java.util.stream.Collectors.toList;
List<Apple> heavyApples =
	inventory.parallelStream().filter((Apple a) -> a.getWeight() > 150)
	                  .collect(toList());
```

> ArrayList와 같은 순차적인 자료구조는 내부적으로 인덱스를 사용하여 요소들에 접근하기 때문에 병렬 처리에 적합하지 않는다.
> 따라서, 병렬 처리를 지원하는 자료구조를 사용해야 한다.
> 병렬 처리가 항상 순차 처리보다 빠른 것은 아니므로, 성능 최적화를 위해서는 실제 데이터에 대한 측정과 분석이 필요하다.

## 1.5 디폴트 메서드와 자바 모듈

요즘은 외부에서 만들어진 컴포넌트를 이용해 시스템을 구축하는 프로그래밍 방식이 유행이다. 지금까지 자바에서는 평범한 자바 패키지 집합을 포함하는 JAR 파일을 제공하는 것이 전부였다. 게다가 이 패키지의 인터페이스를 바꿔야 하는 상황에서는 인터페이스를 구현하는 모든 클래스를 수정해야 했으므로 매우 고통스러운 작업의 연속이다. 이를 해결해주는 것이 자바 8의 **디폴트 메서드**와 자바 9의 **모듈 정의**가 있다.

### 디폴트 메서드

자바 8은 구현 클래스에서 구현하지 않아도 되는 메서드를 인터페이스에 추가할 수 있는 기능을 제공한다. 메서드 본문은 클래스가 아니라 인터페이스의 일부로 포함된다. 그래서 이를 **디폴트 메서드**라 부른다.

디폴트 메서드를 이용하면 기존의 코드를 건드리지 않고 원래의 인터페이스 설계를 자유롭게 확장할 수 있다.

예를 들어 자바 8에서는 List에 직접 sort 메서드를 호출할 수 있다. 이는 자바 8의 List 인터페이스에 다음과 같은 디폴트 메서드 정의가 추가되었기 때문이다.

```Java
default void sort(Comparator<? super E> c){
    Collections.sort(this, c);
}
```

따라서 자바 8 이전에는 List를 구현하는 모든 클래스가 sort 메서드를 구현해야 했지만 자바 8부터는 따로 구현하지 않아도 된다.

### 모듈

자바 9의 모듈 시스템은 모듈을 정의하는 문법을 제공한다. 이를 이용하여 패키지 모음을 포함하는 모듈을 정의할 수 있다. 모듈 덕분에 JAR 같은 컴포넌트에 구조를 적용할 수 있으며 문서화와 모듈 확인 작업이 용이해졌다.

## 1.6 함수형 프로그래밍에서 가져온 다른 유용한 아이디어

지금까지 자바에 포함된 함수형 프로그래밍의 핵심적인 두 아이디어를 살펴보았다.

1. 메서드와 람다를 일급값으로 사용하는 메서드 참조
2. 가변 공유 상태가 없는 병령 실행을 이용하여 안전하고 효율적으로 함수나 메서드 호출

일반적인 함수형 언어도 프로그램을 돕는 여러 장치를 제공한다. 일례로 명시적으로 서술형의 데이터 형식을 이용해 null을 회피하는 기법이 있다.

자바 8에서는 NullPointer 예외를 피할 수 있도록 도와주는 `Optional<T>` 클래스를 제공한다. `Optional<T>`는 값을 갖거나 갖지 않을 수 있는 컨테이너 객체이며, 값이 없는 상황을 어떻게 처리할지 명시적으로 구현하는 메서드를 포함하고 있어 NullPointer 예외를 피할 수 있다.

또한 **구조적 패턴 매칭** 기법도 있다. 여기서 말하는 패턴 매칭은 if-then-else가 아닌 케이스로 정의하는 수학과 함수형 프로그래밍의 기능을 의미한다. 아직 자바 8에서는 완벽하게 지원하지는 않는다.
