## 3.5 형식 검사, 형식 추론, 제약
람다 표현식 자체에는 람다가 어떤 함수형 인터페이스를 구현하는지의 정보가 포함되어 있지 않다. 따라서 람다 표현식을 더 제대로 이해하려면 람다의 실제 형식을 파악해야 한다.

### 형식 검사
람다가 사용되는 context를 이용해서 람다의 형식을 추론할 수 있다. 어떤 context에서 기대되는 람다 표현식의 형식을 **대상 형식**이라고 한다. 다음 코드를 통해 람다의 확인 과정을 알아보자.

```Java
List<Apple> heavierThan150g = filter(inventory, (Apple apple) -> apple.getWeight() > 150);
```
1. `filter` 메서드의 선언을 확인한다.
2. `filter` 메서드는 두 번째 파라미터로 `Predicate<Apple>` 형식(대상 형식)을 기대한다.
3. `Predicate<Apple>`은 `test`라는 한 개의 추상 메서드를 정의하는 함수형 인터페이스이다.
4. `test` 메서드는 `Apple`을 받아 boolean을 반환하는 함수 디스크립터이다.
5. `filter` 메서드로 전달된 인수는 이와 같은 요구사항을 만족해야 한다.

![image](https://github.com/BinarySstar/modern-java-in-action/assets/117090689/6db997ee-b478-4eac-8c61-5e68badbae57)

위 람다 표현식은 `Apple`을 인수로 받아 boolean을 반환하므로 유효한 코드이다.

### 형식 추론
코드를 조금 더 단순화할 수 있는 방법으로 형식 추론이 있다. 자바 컴파일러는 람다 표현식이 사용된 콘텍스트를 이용해서 람다 표현식과 관련된 함수형 인터페이스를 추론한다. 즉, 대상 형식을 이용하여 함수 디스크립터를 알 수 있으므로 컴파일러는 람다의 시그니처도 추론할 수 있다. 컴파일러는 람다 표현식의 파라미터 형식에 접근할 수 있으므로 람다 문법에서 이를 생략할 수 있다.
```Java
List<Apple> greenApples = filter(inventory, apple -> GREEN.equals(apple.getColor())); // 파라미터 apple의 형식을 지정하지 않아도 유효한 코드이다.
```

### 지역 변수 사용 및 제약
람다 표현식에서는 익명 함수가 하는 것 처럼 자유 변수(파라미터로 넘겨진 변수가 아닌 외부에서 정의된 변수)를 활용할 수 있다. 이를 람다 캡처링(lamda capturing)이라 부른다. 하지만 그러려면 지역 변수는 명시적으로 final로 선언되어 있어야 하거나 실질적으로 final로 선언된 변수와 똑같이 사용되어야 한다(이후 재 할당 불가).
```Java
int portNumber = 1337;
Runnable r = () -> System.out.println(portNumber);
portNumber = 60000; // Error!
```
인스턴스 변수는 힙에 저장되는 반면 지역 변수는 스택에 위치한다. 람다에서 지역 변수에 바로 접근할 수 있다는 가정하에 람다가 스레드에서 실행된다면 지역 변수를 할당한 스레드가 사라져서 변수 할당이 해제되었는데도 람다를 실행하는 스레드에서는 해당 변수에 접근하려 할 수 있다. 따라서 자바 구현에서는 원래 변수에 접근을 허용하는 것이 아니라 자유 지역 변수의 복사본을 제공한다. 따라서 복사본의 값이 바뀌지 않아야 하므로 지역 변수에는 한 번만 값을 할당해야 한다는 제약이 생긴것이다.
